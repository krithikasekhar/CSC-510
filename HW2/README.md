# HW2
## Patterns + Selenium Testing
## Define and describe 2 design patterns from each category.
## Creational Patterns:
### Builder pattern: 
  
Builder pattern is a design pattern that can be used when the complexity of an application increases leading to more complex classes and objects. The intent behind using a builder pattern is to separate the construction of a complex object from its representation so that the same construction process can create different representations. It helps in reusability. This pattern allows a client object to construct a complex object by specifying only its type and content, by shielding the details related to the object's representation. This way the construction process can be used to create different representations. The logic of this process is isolated from the actual steps used in creating the complex object, so the process can be used again to create a different object.  
This pattern consists of a director that invokes the 'builder' services as it interprets the external format. The "builder" creates part of the complex object each time it is called and maintains all intermediate states. When the product is finished, the client retrieves the result from the "builder". This method provides finer control over the construction process. Unlike creational patterns that construct products in one shot, the Builder pattern constructs the product step by step under the control of the "director".  
### Singleton pattern:  

The singleton pattern is a design pattern that restricts the instantiation of a class to one object and provides a global point of access to the object. It involves only one class which is responsible to instantiate itself, to make sure it creates not more than one instance. Sometimes it's necessary to have just a single instance of a class, for example, a single database connection that will be used throughout the application. The advantage of Singleton over global variables is that you are sure of the number of instances required when you use Singleton, and also go back and change the number of instances needed if we change our minds. A Singleton must be when the class requires just one instance. It shouldn't be used as a replacement for global variables. To implement the singleton pattern, make the single instance of the class a private static attribute and the accessor function a public static method. This accessor function is called by the client whenever a reference to the single instance is required.  

## Structural patterns:  
### Adapter:

The Adapter pattern is a type of structural design pattern that converts the interface of a class into another interface that the clients expect. It solves the problem of incompatible interfaces and allows classes to work together. It behaves like an adaptor in real life and acts as a bridge between two objects. The problem of reuse is fixed by using adapter patterns as it helps classes function together. While using this pattern, a separate adapter class is defined that converts the incompatible interface of a class, called 'Adaptee' into another interface, called 'Target' that the clients require. The use of a separate adapter means the clients don't know whether they are working with a Target class directly or through an adapter class.  

### Composite:  
The composite pattern composes objects into tree structures to represent whole-part hierarchies. It follows a recursive composition where clients have the freedom to use the objects either as individual ones or as composite objects. This pattern is useful in cases where you need to manipulate a tree structured directory and it is important to treat both branches and leaves uniformly. If you consider a file management system, folders are analogous to branches and files are analogous to leaves. Since both files and folders have many operations and attributes in common, it would be easier to treat them uniformly using the composite pattern.  

## Behavioral patterns:  
### Iterator:  
The iterator pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. This is helpful in data abstraction. The idea of the iterator pattern is to take the responsibility of accessing and passing through the objects of the collection and put it in the iterator object. The iterator object will maintain the state of the iteration, keeping track of the current item and having a way of identifying what elements are next to be iterated.   

### Interpreter:  
The interpreter design pattern will define a representation for the grammar of a given language along with an interpreter that uses the representation to interpret sentences in the language. It maps a domain to a language, a language to a grammar and the grammar to an object-oriented design. Some problems may occur repeatedly in a specific domain. If each domain is mapped to a language, we can use interpreter pattern to solve such problems. The pattern uses a class to represent each grammar rule. And since grammars are usually hierarchical in structure, an inheritance hierarchy of rule classes maps well.  

## Free Style Patterns:  

### Backends for Frontends pattern:  
This pattern is used to create separate backend services to be consumed by specific frontend applications or interfaces. This pattern is useful when you want to avoid customizing a single backend for multiple interfaces. An application may initially be targeted at a desktop web UI. Typically, a backend service is developed in parallel that provides the features needed for that UI. As the application's user base grows, a mobile application is developed that must interact with the same backend. The backend service becomes a general-purpose backend, serving the requirements of both the desktop and mobile interfaces. These differences result in competing requirements for the backend. However, different teams may be working on different interfaces and hence coordination effort is required before integration. The solution is to create one backend per user interface. The behavior and performance of each backend is fine tuned to match the corresponding user interface, thereby shielding it from other front end environments. This pattern can be used when a shared backend service must be maintained with a significant overhead or if you want to optimize the backend for the requirements of specific client interfaces.  

### Cache-Aside pattern:  
The Cache-Aside pattern loads data into a cache from a data store based on the demand. This can improve performance and also helps to maintain consistency between data held in the cache and data in the underlying data store. Whenever data must be accessed repeatedly, cache is used. However, it's impractical to expect that cached data will always be completely consistent with the data in the data store. Applications should ensure that the data in the cache is as up-to-date as possible, but can also detect and handle situations that arise when the data in the cache has become stale. Many commercial caching systems provide read-through and write-through/write-behind operations. In these systems, an application retrieves data by referencing the cache. If the data isn't in the cache, it's retrieved from the data store and added to the cache. Any modifications to data held in the cache are automatically written back to the data store as well. An application must maintain the data in case the cache doesn't provide this functionality. An application can emulate the functionality of read-through caching by implementing the cache-aside strategy. This strategy loads data into the cache on demand.  

### Priority Queue pattern:  
Through the priority queue pattern, we can prioritize requests sent to services so that requests with a higher priority are received and processed more quickly than those with a lower priority. This pattern is useful in applications that offer different service level guarantees to individual clients. Applications can delegate specific tasks to other services, for example, to perform background processing or to integrate with other applications or services. In many cases the order requests are received in by a service isn't important. In some cases, though, it's necessary to prioritize specific requests. Higher priority requests should be processed earlier than lower priority requests that were sent previously by the application.
A queue is a first-in, first-out (FIFO) data structure where consumers receive messages in the same order that they were posted to the queue. However, some message queues support priority messaging. The application posting a message can assign a priority and the messages in the queue are automatically reordered so that those with a higher priority will be received before those with a lower priority.  

## References:
http://www.oodesign.com/  
https://sourcemaking.com/design_patterns/  
https://docs.microsoft.com/en-us/azure/architecture/patterns/  
https://en.wikipedia.org/wiki/Adapter_pattern
